/*定義有向圖形的頂點個數為8*/
#define V 8

/*宣告admatrix[][]陣列存放有向圖形的相鄰矩陣*/ 
int admatrix[V][V] = {0, 1, 1, 1, 0, 0, 0, 0,
                      0, 0, 0, 0, 1, 1, 0, 0,
                      0, 0, 0, 0, 0, 1, 0, 0,
                      0, 0, 0, 0, 0, 0, 1, 0,
                      0, 0, 0, 0, 0, 1, 0, 0,
                      0, 0, 0, 0, 0, 0, 0, 1,
                      0, 0, 0, 0, 0, 0, 0, 1,
                      0, 0, 0, 0, 0, 0, 0, 0};

int indegree[V];  /*記錄每個頂點的進入分支度*/
int outputed[V];  /*記錄每個頂點是否已經輸出，1表示是，0表示否*/                   


/*這個函數會實作拓樸排序*/
topology_sort()
{
  int i, j, Vx;
  
  for (i = 0; i < V; i++){          /*將陣列初始化*/
    indegree[i] = 0;
    outputed[i] = 0;  
  }
      
  for (i = 0; i < V; i++)          /*計算每個頂點的進入分支度*/
    for (j = 0; j < V; j++)
      if (admatrix[i][j] == 1)
        indegree[j]++;
      
  for (i = 0; i < V; i++){         /*拓樸排序的迴圈必須重複V次才能結束*/
    Vx = select_vertex();          /*選擇尚未被輸出且沒有前行者的頂點*/ 
    printf("V%d ", Vx);            /*輸出該頂點並標示為已經輸出*/
    outputed[Vx] = 1; 
    for (j = 0; j < V; j++)        /*將該頂點所連接出去的邊刪除*/ 
      if (admatrix[Vx][j] == 1){    
        admatrix[Vx][j] = 0;                  
        indegree[j]--;
      }
  }    
}

/*這個函數會選擇沒有前行者的頂點，即尚未被輸出且進入分支度為0的頂點*/
select_vertex()
{
  int i;
  for (i = 0; i < V; i++)
    if (outputed[i] == 0 && indegree[i] == 0)
      return i;                             
}

/*主程式*/ 
main()
{
  topology_sort();
  getchar();    
}
